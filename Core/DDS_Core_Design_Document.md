# DDS Core模块设计文档

## 1. 概述

DDS Core模块是基于共享内存的高性能多进程数据分发系统，提供零拷贝、无锁的消息传递机制。

### 1.1 设计目标

- **高性能**: 基于共享内存的零拷贝数据传输
- **多进程安全**: 支持多个进程同时访问和操作
- **实时性**: 低延迟的消息传递和通知机制
- **可扩展性**: 支持动态Topic注册和多订阅者模式

### 1.2 核心组件

1. **SharedMemory**: 共享内存管理器
2. **TopicRegistry**: Topic注册和管理
3. **RingBuffer**: 高性能环形缓冲区
4. **Message**: 消息数据结构定义

## 2. 架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                    DDS Core Architecture                    │
├─────────────────────────────────────────────────────────────┤
│  Process A    │  Process B    │  Process C    │  Process D  │
│  ┌─────────┐  │  ┌─────────┐  │ ┌──────────┐  │ ┌──────────┐│
│  │Publisher│  │  │Publisher│  │ │Subscriber│  │ │Subscriber││
│  └─────────┘  │  └─────────┘  │ └──────────┘  │ └──────────┘│
├─────────────────────────────────────────────────────────────┤
│                   Shared Memory Space                       │
│  ┌─────────────────┐  ┌─────────────────────────────────┐   │
│  │  TopicRegistry  │  │         RingBuffer Pool         │   │
│  │  ┌───────────┐  │  │  ┌─────────┐ ┌─────────┐ ┌───┐  │   │
│  │  │Topic Meta │  │  │  │Topic A  │ │Topic B  │ │...│  │   │
│  │  │  Data     │  │  │  │RingBuf  │ │RingBuf  │ │   │  │   │
│  │  └───────────┘  │  │  └─────────┘ └─────────┘ └───┘  │   │
│  └─────────────────┘  └─────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 内存布局

```
┌─────────────────────────────────────────────────────────────┐
│                    Shared Memory Layout                     │
├─────────────────────────────────────────────────────────────┤
│ Offset 0x0000    │ TopicRegistryHeader (64B aligned)        │
├─────────────────────────────────────────────────────────────┤
│ Offset 0x0040    │ TopicMetadata Array (128 * 128B)         │
│                  │ [MAX_TOPICS = 128]                       │
├─────────────────────────────────────────────────────────────┤
│ Offset 0x4040    │ RingBuffer Data Area                     │
│                  │ ┌─────────────────────────────────────┐  │
│                  │ │ Topic 1 RingBuffer                  │  │
│                  │ │ ┌─────────┬──────────┬────────────┐ │  │
│                  │ │ │ Header  │Subscriber│ Data Area  │ │  │
│                  │ │ │ (64B)   │Registry  │            │ │  │
│                  │ │ │         │(64*64B)  │            │ │  │
│                  │ │ └─────────┴──────────┴────────────┘ │  │
│                  │ └─────────────────────────────────────┘  │
│                  │ │ ...                                 │  │
│                  │ │ Topic 2 RingBuffer                  │  │
│                  │ └─────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

## 3. 数据结构设计

### 3.1 核心数据结构概览

| 结构名称 | 大小 | 对齐 | 主要用途 |
|---------|------|------|----------|
| MessageHeader | 32B | 8B | 消息元数据，包含魔数、序列号、时间戳、校验和 |
| Message | 40B | 8B | 完整消息结构，包含头部和数据指针 |
| SubscriberState | 64B | 64B | 订阅者状态跟踪，缓存行对齐避免false sharing |
| RingBuffer Header | 64B | 64B | 环形缓冲区控制信息，原子操作保证线程安全 |
| TopicMetadata | 128B | 64B | Topic元数据，包含名称、ID、缓冲区信息 |
| TopicRegistryHeader | 64B | 64B | Topic注册表头部，包含全局状态信息 |

### 3.2 MessageHeader字段说明

| 字段名 | 类型 | 大小 | 说明 |
|--------|------|------|------|
| magic | uint32_t | 4B | 魔数，用于消息格式验证 |
| topic_id | uint32_t | 4B | Topic唯一标识符 |
| sequence | uint64_t | 8B | 消息序列号，用于排序和去重 |
| timestamp | uint64_t | 8B | 消息时间戳（纳秒精度） |
| data_size | uint32_t | 4B | 消息数据部分的大小（字节） |
| checksum | uint32_t | 4B | 消息校验和，用于数据完整性验证 |

### 3.3 订阅者状态管理

| 状态字段 | 用途 | 更新时机 |
|----------|------|----------|
| last_read_sequence | 记录最后成功读取的消息序列号 | 消息读取成功后 |
| next_expected_sequence | 下一个期望读取的消息序列号 | 每次读取尝试后递增 |
| active | 订阅者是否处于活跃状态 | 注册时设为true，注销时设为false |
| subscriber_id | 订阅者唯一标识 | 注册时设置，不再更改 |

## 4. 核心逻辑流程

### 4.1 Topic注册流程

```flow
st=>start: 开始注册Topic
op1=>operation: 获取信号量锁
op2=>operation: 遍历Topic元数据数组
cond1=>condition: 找到空闲槽位?
op3=>operation: 释放锁
e1=>end: 返回注册失败
op4=>operation: 计算环形缓冲区大小和偏移
op5=>operation: 初始化Topic元数据
op6=>operation: 原子性更新Topic计数
op7=>operation: 释放信号量锁
e2=>end: 返回注册成功

st->op1->op2->cond1
cond1(no)->op3->e1
cond1(yes)->op4->op5->op6->op7->e2
```

### 4.2 消息发布流程

```flow
st=>start: 接收消息
op1=>operation: 计算消息总大小
op2=>operation: 检查缓冲区剩余空间
cond1=>condition: 空间足够?
e1=>end: 返回发布失败
op3=>operation: 原子获取写入位置
op4=>operation: 检查边界条件
cond2=>condition: 跨越缓冲区边界?
op5=>operation: 重置到缓冲区开始位置
op6=>operation: 在缓冲区构造消息
op7=>operation: 计算并设置校验和
op8=>operation: 执行内存屏障
op9=>operation: 通知所有订阅者
e2=>end: 返回发布成功

st->op1->op2->cond1
cond1(no)->e1
cond1(yes)->op3->op4->cond2
cond2(yes)->op5->op6
cond2(no)->op6
op6->op7->op8->op9->e2
```

### 4.3 订阅者注册流程

```flow
st=>start: 订阅者请求注册
op1=>operation: 获取信号量锁
op2=>operation: 遍历订阅者状态数组
cond1=>condition: 找到非活跃槽位?
op3=>operation: 释放锁
e1=>end: 返回注册失败
op4=>operation: 初始化订阅者状态
op5=>operation: 原子性激活订阅者状态
op6=>operation: 释放信号量锁
e2=>end: 返回注册成功

st->op1->op2->cond1
cond1(no)->op3->e1
cond1(yes)->op4->op5->op6->e2
```

### 4.4 消息订阅流程

```flow
st=>start: 订阅者请求读取
op1=>operation: 查找订阅者状态
cond1=>condition: 订阅者存在且活跃?
e1=>end: 返回读取失败
op2=>operation: 获取期望序列号
op3=>operation: 获取当前写入序列号
cond2=>condition: 有新消息可读?
e2=>end: 返回无新消息
op4=>operation: 根据序列号查找消息位置
cond3=>condition: 消息存在?
op5=>operation: 处理消息丢失，跳到最新消息
op6=>operation: 验证消息完整性
cond4=>condition: 消息完整?
op7=>operation: 跳过损坏消息，递增期望序列号
op8=>operation: 更新订阅者状态
e3=>end: 返回消息给订阅者

st->op1->cond1
cond1(no)->e1
cond1(yes)->op2->op3->cond2
cond2(no)->e2
cond2(yes)->op4->cond3
cond3(no)->op5->e2
cond3(yes)->op6->cond4
cond4(no)->op7->e2
cond4(yes)->op8->e3
```

### 4.5 通知机制流程

#### 4.5.1 生产者通知流程

```flow
st=>start: 消息发布完成
op1=>operation: 原子递增通知计数器
op2=>operation: 调用futex_wake唤醒等待的订阅者
e=>end: 通知完成

st->op1->op2->e
```

#### 4.5.2 消费者等待流程

```flow
st=>start: 订阅者请求等待
op1=>operation: 获取当前通知计数
op2=>operation: 检查是否有未读消息
cond1=>condition: 有未读消息?
e1=>end: 立即返回有消息
op3=>operation: 调用futex_wait等待通知
cond2=>condition: 被唤醒或超时?
e2=>end: 返回有新消息
e3=>end: 返回等待超时

st->op1->op2->cond1
cond1(yes)->e1
cond1(no)->op3->cond2
cond2(yes)->e2
cond2(no)->e3
```

## 5. 系统状态转换

### 5.1 Topic生命周期

| 状态 | 描述 | 转换条件 |
|------|------|----------|
| 未注册 | Topic不存在于系统中 | 初始状态 |
| 已注册 | Topic已创建，可以发布和订阅 | 成功调用register_topic |
| 活跃 | 有发布者或订阅者在使用 | 有进程连接到Topic |
| 非活跃 | 暂时无进程使用，但Topic仍存在 | 所有进程断开连接 |

### 5.2 订阅者状态转换

| 状态 | 描述 | 可执行操作 |
|------|------|------------|
| 未注册 | 订阅者未在系统中注册 | 无法读取消息 |
| 已注册 | 订阅者已注册但未开始读取 | 可以开始读取消息 |
| 正常读取 | 订阅者正常跟上消息流 | 顺序读取消息 |
| 落后 | 订阅者读取速度慢于发布速度 | 继续读取或跳到最新 |
| 丢失消息 | 订阅者错过了某些消息 | 自动跳到可用的最新消息 |

## 6. 性能优化特性

### 6.1 内存优化策略

| 优化技术 | 应用位置 | 效果 |
|----------|----------|------|
| 64字节对齐 | 关键数据结构 | 避免false sharing，提高缓存效率 |
| 数据局部性 | 相关数据紧密排列 | 减少缓存未命中 |
| 预分配内存 | 共享内存段 | 减少运行时内存分配开销 |

### 6.2 并发优化策略

| 技术 | 应用场景 | 优势 |
|------|----------|------|
| 原子操作 | 序列号、位置更新 | 无锁并发，高性能 |
| 内存屏障 | 消息发布完成 | 确保操作顺序和可见性 |
| Futex通知 | 进程间通信 | 高效的等待/唤醒机制 |
| 信号量保护 | 注册操作 | 保护临界区，确保一致性 |

### 6.3 数据传输优化

| 特性 | 实现方式 | 收益 |
|------|----------|------|
| 零拷贝 | 共享内存直接访问 | 消除数据拷贝开销 |
| 指针传递 | 传递内存地址而非数据 | 减少内存带宽使用 |
| 批量通知 | 一次通知多个订阅者 | 减少系统调用次数 |

## 7. 错误处理策略

### 7.1 消息完整性保护

| 检查项 | 检查方法 | 发现错误时的处理 |
|--------|----------|------------------|
| 魔数验证 | 比较预定义魔数值 | 跳过该消息，继续读取下一个 |
| 校验和验证 | 重新计算并比较 | 标记消息损坏，跳过处理 |
| 大小合理性 | 检查数据大小范围 | 拒绝处理异常大小的消息 |
| 序列号连续性 | 检查序列号是否连续 | 检测消息丢失，自动跳转 |

### 7.2 系统恢复机制

| 错误类型 | 检测方法 | 恢复策略 |
|----------|----------|----------|
| 订阅者掉队 | 序列号差距过大 | 自动跳转到最新消息 |
| 缓冲区满 | 写入位置检查 | 发布者等待或丢弃旧消息 |
| 进程异常退出 | 心跳检测 | 清理相关状态，释放资源 |
| 共享内存损坏 | 魔数和校验和 | 重新初始化或切换备用内存 |

## 8. 总结

DDS Core模块通过精心设计的数据结构和算法，实现了高性能的多进程数据分发系统：

### 8.1 核心优势

1. **Topic注册**: 基于信号量保护的线程安全注册机制，支持动态Topic管理
2. **消息发布**: 无锁的原子操作确保高并发性能，智能边界处理
3. **订阅管理**: 独立的订阅者状态跟踪，支持不同速度的消费者
4. **通知机制**: 基于futex的高效进程间通知，最小化延迟

### 8.2 适用场景

- 高频数据分发系统
- 实时消息传递应用
- 多进程协作系统
- 低延迟通信需求

该设计为构建实时、高性能的分布式系统提供了坚实的基础。